package com.github.zachsand.hs.deck.generator.controller;

import com.github.zachsand.hs.deck.generator.model.deck.DeckRequestModel;
import com.github.zachsand.hs.deck.generator.model.deck.DeckResponseModel;
import com.github.zachsand.hs.deck.generator.model.deck.DeckResponseStatus;
import com.github.zachsand.hs.deck.generator.model.deck.validator.DeckRequestValidator;
import com.github.zachsand.hs.deck.generator.service.DeckGeneratorService;
import com.github.zachsand.hs.deck.generator.service.HearthstoneMetadataService;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.io.PrintWriter;
import java.io.StringWriter;

/**
 * The deck generation controller that controls the deck generation endpoints.
 */
@RestController
@RequestMapping("api")
public class DeckGeneratorController {

    private static final Logger logger = LogManager.getLogger(DeckGeneratorController.class);

    private DeckGeneratorService deckGeneratorService;

    private HearthstoneMetadataService hearthstoneMetadataService;

    private DeckRequestValidator deckRequestValidator;

    /**
     * Constructs the controller for the deck generation.
     *
     * @param deckGeneratorService The deck generation service to generate Hearthstone decks.
     */
    public DeckGeneratorController(DeckGeneratorService deckGeneratorService, HearthstoneMetadataService hearthstoneMetadataService, DeckRequestValidator deckRequestValidator) {
        this.deckGeneratorService = deckGeneratorService;
        this.hearthstoneMetadataService = hearthstoneMetadataService;
        this.deckRequestValidator = deckRequestValidator;
    }

    /**
     * The deck generation endpoint for generating a deck. If successful, this will create a deck code and return the
     * deck code, and an associated ID of the created entity.
     *
     * @param deckRequestModel The {@link DeckRequestModel} for the required arguments for generating a hearthstone deck.
     * @return The {@link DeckResponseModel} which contains the deck code and associated ID.
     */
    @PostMapping(path = "/deck", consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<DeckResponseModel> generateDeck(@RequestBody DeckRequestModel deckRequestModel) {
        logger.info("Request received {}", deckRequestModel);
        try {
            hearthstoneMetadataService.refreshMetadata();

            DeckResponseStatus deckResponseStatus = deckRequestValidator.validateDeckRequest(deckRequestModel);
            if (deckResponseStatus.getStatus().equals(DeckResponseStatus.ResponseStatus.ERROR.name())) {
                DeckResponseModel errorResponse = new DeckResponseModel();
                errorResponse.setStatus(deckResponseStatus);
                return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
            }
            return new ResponseEntity<>(deckGeneratorService.generateDeck(deckRequestModel), HttpStatus.CREATED);
        } catch (Exception e) {
            return new ResponseEntity<>(mapExceptionResponse(e), HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    /**
     * The deck retrieval endpoint for a deck that has already been generated by the
     * {@link DeckGeneratorController#generateDeck} creation endpoint.
     *
     * @param id The ID of the deck to retrieve.
     * @return The {@link DeckResponseModel} which contains the deck code and associated ID.
     */
    @GetMapping(path = "/deck/{id}", produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<DeckResponseModel> getDeck(@PathVariable Integer id) {
        return new ResponseEntity<>(deckGeneratorService.getDeck(id), HttpStatus.OK);
    }

    /**
     * Deletes the deck associated with the ID.
     *
     * @param id The ID of the deck to delete.
     * @return {@link HttpStatus#NO_CONTENT}
     */
    @DeleteMapping
    public ResponseEntity<HttpStatus> deleteDeck(@PathVariable Integer id) {
        deckGeneratorService.deleteDeck(id);
        return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    }

    private DeckResponseModel mapExceptionResponse(Exception e) {
        logger.error(e);
        DeckResponseModel deckResponseModel = new DeckResponseModel();
        DeckResponseStatus deckResponseStatus = new DeckResponseStatus();
        deckResponseStatus.setStatus(DeckResponseStatus.ResponseStatus.ERROR.name());

        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw);
        e.printStackTrace(pw);

        String[] errorMessages = new String[3];
        errorMessages[0] = "Exception encountered while processing the request.";
        errorMessages[1] = e.getMessage();
        errorMessages[2] = pw.toString();

        deckResponseStatus.setMessage(errorMessages);
        deckResponseModel.setStatus(deckResponseStatus);
        logger.debug("Error response {}.", deckResponseModel);
        return deckResponseModel;
    }
}
